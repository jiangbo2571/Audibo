# Audibo Challenge Response Generator
# Fixed version using cryptography library for proper signing
import binascii
import random
import string
import os
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.serialization import load_pem_private_key

def get_random_unicode(length):
    """Generate random Unicode characters from specified ranges"""
    try:
        get_char = unichr  # Python 2
    except NameError:
        get_char = chr     # Python 3
    include_ranges = [(128, 999)]
    alphabet = [
        get_char(code_point) 
        for current_range in include_ranges 
        for code_point in range(current_range[0], current_range[1] + 1)
    ]
    return ''.join(random.choice(alphabet) for _ in range(length))

def process_challenge(challenge, private_key):
    """Process the challenge string and generate signed response"""
    try:
        challenge_array = challenge.split('0A')
        if len(challenge_array) < 4:
            raise ValueError("Invalid challenge format - expected 4 segments separated by 0A")
            
        print('-' * 80)
        random_data = challenge_array[1]
        
        # Generate random components
        random_string = get_random_unicode(9)
        random_string2 = ''.join(
            random.choice(string.punctuation + string.whitespace) 
            for _ in range(5)
        )
        
        # Construct the data to be signed
        data_parts = [
            binascii.unhexlify(random_data).decode('utf-8'),
            '\n' + random_string + binascii.unhexlify(challenge_array[3]).decode('utf-8'),
            '\n' + binascii.unhexlify(challenge_array[2]).decode('utf-8')
        ]
        data = ''.join(data_parts).encode('utf-8')
        
        # Generate the signature
        signature = private_key.sign(
            data,
            padding.PKCS1v15(),
            hashes.SHA256()
        )
        
        # Build the response
        response_parts = [
            random_data,
            '0A',
            binascii.hexlify(random_string.encode('utf-8')).decode('utf-8').upper(),
            binascii.hexlify(random_string2.encode('utf-8')).decode('utf-8').upper(),
            signature.hex().upper()
        ]
        response = ''.join(response_parts)
        
        print(f' [RESPONSE] {response}')
        return response
        
    except Exception as e:
        print(f' [!] Error processing challenge: {str(e)}')
        raise

def main():
    print(' @ Audibo Challenge Response Generator')
    print(' @ NOTE: Please place private.pem in the same directory as this script.')
    print('-' * 80)
    
    # Check for private key file
    if not os.path.exists('private.pem'):
        print(' [!] private.pem not found in current directory')
        input('\nPress Enter to exit...')
        return
    
    # Load private key
    try:
        with open('private.pem', 'rb') as key_file:
            private_key = load_pem_private_key(
                key_file.read(),
                password=None,
                backend=default_backend()
            )
    except Exception as e:
        print(f' [!] Failed to load private key: {str(e)}')
        input('\nPress Enter to exit...')
        return
    
    # Main processing loop
    while True:
        challenge = input('\n [CHALLENGE] (Enter "exit" to quit) ')
        
        if challenge.lower() == 'exit':
            break
            
        if not challenge.strip():
            print(' [!] Challenge cannot be empty')
            continue
            
        try:
            process_challenge(challenge, private_key)
        except:
            print(' [!] Failed to process challenge (see error above)')
            continue
    
    print('\nGenerator stopped')

if __name__ == '__main__':
    main()
